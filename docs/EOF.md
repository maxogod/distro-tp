# Explicación del EOF del sistema

Para realizar el EOF del sistema, decidimos implementar una lógica de conteo utilizando un exchange direct `CounterExchange` usando el `clientId` en conjunto con el **tipo de worker** (Filter, Reducer, Joiner, etc) como routing key. La idea de este exchange es que tanto el `Gateway Controller` como los workers envíen mensajes (con el `clientId` correspondiente) indicando la cantidad de batches que fueron enviados al siguiente worker por cada batch recibido del worker anterior. Esto permite que el `Gateway Controller` pueda llevar un conteo exacto de los batches enviados y recibidos por cada cliente en cada worker stage, pudiendo identificar el momento exacto en el que una stage terminó de procesar todos los batches enviados para un cliente determinado. Esto nos permite tener un seguimiento determinístico del flujo de mensajes por cliente en cada etapa del procesamiento, pudiendo así gestionar adecuadamente el EOF del sistema y notificarle al `Aggregator` (mediante el `finishExchange`) cuando un cliente completó todo su procesamiento y su data procesada puede comenzar a ser enviada nuevamente hacia el `Gateway Controller`.

Inicialmente, el `Gateway Controller` comienza a enviar a la `FilterQueue` los batches de un cliente específico. Luego, por cada batch recibido, el Filter Worker enviará un `MessageCounter` a la `CounterExchange` usando la routing key `clientId@filter`, indicando desde que stage llega el mensaje (Filter), a que stage se lo envía (Aggregator para la task 1 y Group by para las task 2 a 4) y cuántos batches fueron enviados al siguiente worker a partir del batch procesado. Así, como el Gateway Controller sabe cuantos batches envió inicialmente para ese cliente al Filter, puede llevar un conteo de cuántos mensajes debe recibir del Filter desde el `CounterExchange` para saber cuando el procesamiento de esa etapa fue terminado. Una vez que la cantidad de batches enviados coincide con la cantidad de batches ya procesados por los filters, el Gateway Controller sabe que el Filter terminó de procesar todos los batches para ese cliente y empieza a analizar la siguiente etapa de procesamiento. Esto es un proceso que se repite para cada etapa del pipeline de procesamiento hasta llegar a la etapa final.

Una vez que la última etapa de procesamiento (Filter para la taks 1 y Joiner para el resto de tasks) termina de procesar todos los batches para un cliente, el Gateway Controller envía un mensaje al `finishExchange` con la routing key `aggregator`, indicando que el procesamiento para ese cliente finalizó y que el `Aggregator` puede comenzar a enviar la data procesada de vuelta al `Gateway Controller`. Luego, una vez que termina de recibir toda la data procesada del `Aggregator`, el `Gateway Controller` envía otro mensaje al `finishExchange` pero ahora con la routing key `joiner`, indicandole al Joiner que el procesamiento para ese cliente finalizó y que puede borrar toda la reference data que tenía almacenada para ese cliente.